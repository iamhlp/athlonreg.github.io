---
layout:     post
title:      金币阵列问题
date:       2017-09-03
author:     athlonreg
header-img: img/hacker.jpg
catalog: true
tags:
---


#include <stdio.h>


#define row 4

#define col 3


int source[row][col] = {{1,0,1}, {0,0,0}, {1,1,0}, {1,0,1}};           	//原阵列

int target[row][col] = {{1,0,1}, {1,1,1}, {0,1,1}, {1,0,1}};         	//目标阵列

int temparr[row][col];							//中间阵列

int number = 0;                                                  	//转换的次数

int minnum = 9999;



void raw_change(int i) {                                              	//行翻转
    
	int j;
    
	for(j=0; j<col; j++) {
        
		temparr[i][j] = 1-temparr[i][j];
    
	}
    
	number++;
    

}



void col_exchange(int i, int j) {                                    	//列交换
    
	int temp, k;
    
	for(k=0; k<row; k++) {
        
		temp = temparr[k][i];
        
		temparr[k][i] = temparr[k][j];
        
		temparr[k][j] = temp;
        
    
	}
    
	if(i != j)
        
		number++;

}



int judge(int i, int j) {                                           	//中间阵列temparr的i列是否和目标阵列target的j列相同
    
	int flag;
    
	for(int k=0; k<row; k++) {
        
		flag=1;
        
		if(temparr[k][i] != target[k][j]) {
            
			flag=0;
            
			break;
        
		}
    
	}
    
	return flag;

}




int main() {
    
    
	int i,j,k;
    
	for(i=0; i<col; i++) {                                      	//代表原阵列source的列
        
		for(j=0; j<row; j++) {
            
			for(k=0; k<col; k++) {
                
				temparr[j][k] = source[j][k];                              
			}
        
		}
    
    
        
		number=0;
        
		col_exchange(0,i);                                      //中间阵列temparr的列先做交换，把其他列放到第一列的位置
  
      
        
        
		for(j=0; j<row; j++) {                                 	//判断temparr的第0列和target的第0列是否相同，不同则翻转
            
			if(temparr[j][0] != target[j][0]) {
                
					raw_change(j);                	//如果第1列不匹配，那么行全部翻转
            
			}
        
		}
        
        

		int found;
        
			for(j=0; j<col; j++) {                       	//代表原阵列target，从第2行开始，到最后一行
            
			found=0;
            
			for(k=j; k<col; k++) {                       	//代表目标阵列temparr，从第2行开始，直到最后一行
                
				if(judge(k, j)) {
                    
					found=1;
                    
					col_exchange(k, j);
                    
					break;
                
				}
            
			}
            
			if(!found) {
                
				break;
            
			}
        
		}
        
		if(found) {
            
			minnum=number;
        
		}
        
    
	}
    

	if(minnum<9999) {
        
		printf("一共变换%d次！\n", minnum);
    
	}
    
	else{
        
		printf("无解！\n");
    
	}
  
  
	return 0;

}

![2017-09-03-1](http://ovefvi4g3.bkt.clouddn.com/2017-09-03-1-1.png)

![2017-09-03-2](http://ovefvi4g3.bkt.clouddn.com/2017-09-03-2-1.png)



---
layout:     post
title:      字典序问题
date:       2017-08-31
author:     athlonreg
header-img: img/MAC.jpg
catalog: true
tags:
---


//
//  main.c
//  2017-08-31-字典序问题
//
//  Created by athlonreg on 2017/8/31.
//  Copyright © 2017年 athlonreg. All rights reserved.
//

#include <stdio.h>
#include <string.h>

int getCombinatorialNumber(int m, int n)
{
    int n_Product=1, m_Product=1;
    int i;
    
    for(i=1; i<=n; i++)
        n_Product*=i;
    for(i=m; i>m-n; i--)
        m_Product*=i;
    
    return m_Product/n_Product;
}

int main(int argc, const char * argv[]) {
    // insert code here...
    int number;                                               //要统计字符串的个数
    int sum;                                                  //存放字符串的序号
    int length;
    char str[10];                                             //存放字符串
    int a[10];                                                //存放字符串的每一位字符的值
    int i, j;
    
    scanf("%d", &number);
    while(number--)
    {
        getchar();
        sum=1;
        scanf("%s", str);
        length=(int)strlen(str);
        
        for(i=1; i<length; i++)
        {
            sum+=getCombinatorialNumber(26, i);               //小于字符串长度的字符串个数
        }
        
        for(i=0; i<length; i++)
        {
            a[i]=str[i]-96;                                   //计算每个字符从a开始的序号数值, a~z分别对应1~26
//            printf("%d ", a[i]);
        }
        //printf("%d\n", f(26, 2));
        
        int temp=1;
        for(i=length; i>0; i--)
        {
            for(j=temp; j<a[length-i]; j++)
            {
                sum+=getCombinatorialNumber(26-j, i-1);       //依次扫描字符，计算所有情况
            }
            temp=a[length-i]+1;
        }
        printf("%d\n", sum);
    }
    return 0;
}

![20170831-zidianxu](http://ovefvi4g3.bkt.clouddn.com/20170831-zidianxu-1.png)


